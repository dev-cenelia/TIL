JavaScript: this, strict mode, arrow function this, call/apply/bind 정리
1. this란 무엇인가?

this는 함수가 실행될 때 결정되는 값이며,
가장 정확한 정의는 다음과 같다.

this의 정의

this는 “함수를 실행한 주체(Caller)”를 가리키는 값이다.

즉, 함수가 호출되는 방식에 따라 this가 달라진다.

this가 결정되는 대표 케이스

일반 함수 호출

strict mode: this = undefined

non-strict mode: this = 전역 객체(window)

객체의 메서드 호출

this = 메서드를 호출한 객체

생성자 호출(new)

this = new로 생성된 새 객체

call/apply/bind로 호출

this = 직접 지정한 값

화살표 함수

this를 생성하지 않음

바깥 스코프의 this를 그대로 사용(lexical this)

2. strict mode란?

strict mode는 JavaScript를 더 안전하게 사용하도록 하는 “엄격 모드”.

strict mode 특징

일반 함수 호출에서 this가 window가 아니라 undefined

선언되지 않은 변수를 사용하면 오류 발생

중복 매개변수 금지

delete로 삭제 불가능한 값 삭제 시 에러

with 문 사용 금지

선언 방식
"use strict";


혹은 함수 내부에 선언하면 그 함수만 strict 적용.

this와 strict 관계

strict mode에서 일반 함수 호출 시:

function a() {
  console.log(this);
}
a(); // undefined


strict가 없으면 window가 된다.

3. 화살표 함수의 this (Lexical this)
핵심 개념

화살표 함수는 this를 생성하지 않으며,
this가 필요하면 바깥 스코프에서 this를 그대로 가져온다.

즉,

화살표 함수 안의 this = 자신을 감싸는 함수의 this

예시
const obj = {
  hi: () => console.log(this)
};
obj.hi(); // obj가 아니라 전역 this


왜냐하면, 객체는 스코프가 아니기 때문.
화살표 함수는 오직 “바깥 함수 스코프” 기준으로 this를 찾는다.

깊은 함수 구조에서도 동일
function a() {
  const b = () => {
    const c = () => {
      console.log(this);
    };
    c();
  };
  b();
}

a.call({ name: "sam" });
// c 안의 this도 { name: "sam" }


b, c 모두 화살표 함수이므로 this를 만들지 않고
바깥(a)의 this를 타고타고 올라가 가져온다.

유지보수 주의

깊은 스코프 + 화살표 함수 + this
조합은 this 출처를 추적하기 어려워 유지보수 측면에서 위험하다.

4. new와 this의 관계
new가 하는 일(실제 내부 동작)
const a = new User("sam");


new는 내부적으로 다음 4단계를 수행한다:

새로운 빈 객체 생성

새 객체의 __proto__를 User.prototype으로 연결

User 함수 내부에서 this = 새 객체로 바인딩

그 새 객체를 반환

그래서 생성자 함수 내부의 this는 새로 만들어진 인스턴스를 가리킨다.

5. call / apply / bind
공통 정의

함수의 this를 강제로 지정하는 메서드들.

call

this를 지정하고 즉시 실행

fn.call(thisArg, arg1, arg2);

apply

call과 동일하지만 인자를 배열로 전달

fn.apply(thisArg, [argsArray]);

bind

this를 지정하지만 즉시 실행하지 않고,
this가 고정된 새로운 함수를 반환

const newFn = fn.bind(thisArg);

비교표
메서드	this 지정	즉시 실행	인자 전달
call	가능	O	하나씩
apply	가능	O	배열
bind	가능	X (새 함수 반환)	나중에 전달
6. 오늘 공부하면서 궁금했던 것들 정리
Q1. strict는 호출 순서와 관계 있나?

아님.
strict는 함수 정의 시점에 이미 파싱되며,
호이스팅 때문에 호출이 먼저 나와도 strict 적용된다.

Q2. 화살표 함수는 this를 안 만들면 this 못 쓰는 건가?

아님.
this를 생성하지 않을 뿐,
필요하면 바깥 함수의 this를 타고 올라가서 사용함.

Q3. 화살표 함수 안의 this가 obj가 아닌 이유?

obj는 스코프가 아니라 “단순한 객체”이기 때문.
화살표 함수는 오직 바깥 “함수 스코프”에서 this를 찾는다.

Q4. 깊은 함수에서 화살표 함수 사용하면 유지보수 어렵나?

그렇다.
this 출처를 추적하기 매우 어려워지므로 신중하게 사용해야 한다.
